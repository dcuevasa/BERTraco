#!/usr/bin/env python3
"""
animalese_like.py

Simple, lightweight "Animal Crossing"-like voice generator in Python.

Requirements:
  - Python 3.7+
  - pydub (pip install pydub)
  - ffmpeg installed and available in PATH (for pydub to load/save many formats)

Concept:
  - You provide up to 5 short audio samples (WAV/MP3) of simple syllables (e.g. "ba","gi","do").
  - The script maps characters in the input text to those samples, applies a small random pitch shift
    (by changing sample frame_rate), and concatenates them into a single output file.
  - This is intentionally simple and lightweight (no heavy DSP libraries). It aims for a similar
    playful effect, not a perfect replica of Animal Crossing's "Animalese".

Usage example:
  python3 animalese_like.py --samples samples/ --text "hola mundo" --out out.wav --seed 1

Author: Generated by ChatGPT for the user.
"""

import argparse
import os
import random
from pydub import AudioSegment

# -------------------- Utility functions --------------------
def change_pitch(audio_seg: AudioSegment, semitones: float) -> AudioSegment:
    """
    Change pitch by altering the frame rate and then resampling back to 44100 Hz.
    This is a cheap-and-fast method that alters duration as well (good enough for this use-case).
    semitones: positive -> higher pitch, negative -> lower pitch.
    """
    # El factor de velocidad base de 2.0 duplica la velocidad (y sube el tono 12 semitonos).
    # El factor de tono aleatorio se aplica sobre eso.
    # La nueva fórmula suma los semitonos en lugar de multiplicar los factores de velocidad.
    total_semitones = 12 + semitones
    speed_factor = (total_semitones / 12.0)

    new_rate = int(audio_seg.frame_rate * speed_factor)
    # spawn a new AudioSegment with altered frame_rate, then set frame rate to 44100 so it plays
    shifted = audio_seg._spawn(audio_seg.raw_data, overrides={"frame_rate": new_rate}).set_frame_rate(44100)
    return shifted

def load_samples(folder: str, max_samples: int = 5, trim_ms: int = 180) -> list:
    """
    Load up to max_samples audio files from folder (sorted by name). Trim each to trim_ms milliseconds max.
    Returns list of AudioSegment
    """
    files = sorted([os.path.join(folder, f) for f in os.listdir(folder)
                    if f.lower().endswith((".wav", ".mp3", ".ogg", ".flac", ".m4a"))])
    if not files:
        raise FileNotFoundError(f"No audio files found in {folder}. Place up to {max_samples} syllable files in that folder.")
    files = files[:max_samples]
    segs = []
    for p in files:
        seg = AudioSegment.from_file(p)
        # normalize to mono and 16-bit 44.1k for consistency
        seg = seg.set_frame_rate(44100).set_sample_width(2).set_channels(1)

        # Recortar 15ms del inicio y 15ms del final para limpiar el audio
        trim_amount = 15
        if len(seg) > trim_amount * 2:
            seg = seg[trim_amount:-trim_amount]

        # Eliminamos el recorte a una longitud máxima para usar el audio completo
        # if len(seg) > trim_ms:
        #     seg = seg[:trim_ms]
        segs.append(seg)
    return segs

# -------------------- Main generator --------------------
def text_to_animalese(text: str, samples: list, pitch_range_semitones: int = 7,
                      syllable_len_ms: int = 140, gap_ms: int = 30, seed=None) -> AudioSegment:
    """
    Convert text into a synthetic 'animalese-like' audio stream using provided samples.
    - text: input string
    - samples: list of AudioSegment syllables (length up to 5 expected)
    - pitch_range_semitones: maximum absolute semitone shift (random between -range..+range)
    - syllable_len_ms: target duration for each syllable (samples will be trimmed/padded)
    - gap_ms: silence between syllables
    """
    if seed is not None:
        random.seed(seed)

    out = AudioSegment.silent(duration=0)
    silence_short = AudioSegment.silent(duration=gap_ms)

    # Ya no pre-procesamos los audios a una longitud fija. Usamos los originales.
    proc_samples = samples

    # Map characters to samples using a small deterministic mapping so same input -> similar output
    for ch in text:
        if ch.isspace():
            # Usamos un silencio de duración media para los espacios
            out += AudioSegment.silent(duration=80)
            continue
        # pick sample index by character code to distribute over available samples
        idx = ord(ch) % len(proc_samples)
        base = proc_samples[idx]
        # pick a random semitone shift within range
        semitone = random.uniform(-pitch_range_semitones, pitch_range_semitones)
        changed = change_pitch(base, semitone)
        # Eliminamos la aleatorización de la duración y el recorte. Usamos el audio completo.
        out += changed + silence_short

    # small fade to reduce clicks
    out = out.fade_in(5).fade_out(50)
    return out

# -------------------- CLI --------------------
def main():
    parser = argparse.ArgumentParser(description="Generate Animal Crossing-like speech from text using a few syllable samples.")
    parser.add_argument("--samples", required=True, help="Folder with up to 5 short audio sample files (wav/mp3/ogg).")
    parser.add_argument("--text", required=True, help="Text to convert to 'animalese'. Use quotes.")
    parser.add_argument("--out", default="animalese_out.wav", help="Output WAV filename.")
    parser.add_argument("--pitch_range", type=int, default=4, help="Max semitone shift (default 4).")
    parser.add_argument("--syllable_ms", type=int, default=140, help="Target syllable length in milliseconds.")
    parser.add_argument("--gap_ms", type=int, default=30, help="Gap between syllables in ms.")
    parser.add_argument("--seed", type=int, default=None, help="Random seed for reproducibility.")
    args = parser.parse_args()

    samples = load_samples(args.samples, max_samples=5, trim_ms=300)
    out_seg = text_to_animalese(args.text, samples, pitch_range_semitones=args.pitch_range,
                                syllable_len_ms=args.syllable_ms, gap_ms=args.gap_ms, seed=args.seed)
    out_seg.export(args.out, format="wav")
    print(f"Saved -> {args.out}")

if __name__ == "__main__":
    main()
